package apr.learning.pattern.structural.decorator.info;

-------- DECORATOR PATTERN --------

#1- Intro
La intención del patrón Decorator es unir responsabilidades adicionales a un objeto de forma dinámica.
Decorator proporciona una alternativa flexible a las sub clases para extender funcionalidad.
el patrón decorador se utiliza para extender funcionalidad a un objeto de forma dinámica
sin tener que cambiar el código fuente original o usar herencia. Esto se logra mediante la creación
de una envoltura del objeto, referida como Decorator.
 
El objeto Decorator está diseñado para tener la misma interfaz que el objeto subyacente.
Esto permite al cliente interactuar con el objeto decorator exactamente de la misma manera que lo 
haría con el objeto real. El objeto decorator contiene una referencia al objeto real. El objeto 
decorator recibe todas las peticiones de un cliente. A su vez reenvía estas llamadas
al objeto subyacente. El objeto del decorador añade algunas funciones adicionales antes o después
de reenviar solicitudes al objeto subyacente. Esto asegura que la funcionalidad adicional
se puede añadir a un objeto dado externamente en tiempo de ejecución sin modificar su estructura.
 
Decorator evita la proliferación de subclases que conducen a una menor complejidad y confusión.
Es fácil agregar cualquier combinación de capacidades. Las mismas capacidades pueden incluso 
añadirse dos veces. Es posible tener en un momento dado diferentes objetos Decorator para un
el mismo objeto. Un cliente puede elegir que capacidades quiere para enviar el mensaje
hacia el decodator apropiado.

#2- Actores
	-Component:
		Define la interfaz para los objetos que puede tener responsabilidades añadidas de forma dinámica
	-ConcreteComponent
		Define un objeto para las responsabilidades añadidas  
	-Decorator
		Mantiene una referencia a un Component y define la interfaz que ajusta la interfaz del Component
	-ConcreteDecorator
		Añade las responsabilidades al componente

El patrón decorador es válido cuando se necesita añadir funcionalidad adicional a un objeto en tiempo de
ejecución. Pero este resultado da lugar a un montón de pequeños objetos. Un diseño que utiliza Decorator
a menudo resulta en sistemas compuestos por un montón de pequeños objetos que parecen todos iguales.
Los objetos solo se diferencian en la forma en que están interconectados, no en su clase o en el valor 
de sus variables. Aunque estos sistemas son fáciles de personalizar por quienes los entienden, pueden
ser difíciles de aprender y depurar.

#3- Cuando usar el patrón
	- Cuando se quiera añadir responsabilidades a los objetos individuales de forma dinámica
	y transparente.
	- Cuando la extensión por sub-clases es poco práctica. A veces, son posibles un gran 
	numero de extensiones independientes y produciría una explosión de subclases para apoyar cada
	combinación. 

